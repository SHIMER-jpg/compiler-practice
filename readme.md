## Goal

Write a compiler that is able to process a sub-set of Rust-like features into WASM.

```rust
  func add(x: int, y: int) -> int {
      return x + y;
  }

  func main() -> int {
      let a: int = 5;
      let b: int = 3;

      let sum: int = add(a, b);

      if sum > 7 {
          print("The sum is greater than 7.");
      } else {
          print("The sum is less than or equal to 7.");
      }

      return 0;
  }
```


## Week 1: General Architecture Understanding, Language Definition, and Lexical Analysis (Tokenizing)

1. Learn about the basics of compiler architecture, including the main components and their roles (lexical analysis, parsing, semantic analysis, intermediate representation, code generation, and optimization).

2. Define the syntax and semantics of your level 6 language. Write a formal grammar, and decide on the language's data types, control structures, and function handling. You can start with a simple subset of the language and expand it later if desired.

3. Learn about lexical analysis techniques and tools, such as regular expressions and scanner generators like Lex, Flex, or their Rust counterparts.

4. Implement a lexical analyzer (tokenizer) for your language. Write code or rules to recognize keywords, identifiers, literals, operators, and punctuation symbols specific to your language. Ensure that your tokenizer can process a source file and generate a sequence of tokens as output.

## Week 2: Parsing (Syntax Analysis) and Basic Semantic Analysis

1. Learn about parsing techniques, such as recursive descent parsing and parser generators (e.g., LALR or LL). Decide which approach you want to use for your project.

2. Implement a parser that takes the tokens generated by your lexical analyzer and builds an Abstract Syntax Tree (AST) representing the input program's structure. This will involve writing code to handle each of the language constructs (e.g., expressions, control structures, and function declarations).

3. Perform basic semantic analysis during the parsing process. This can include checking for undefined variables and type mismatches, ensuring that variables are declared before use, and enforcing basic scoping rules.

## Week 3: Code Generation, Simple Interpreter, and Testing

1. Learn about different code generation strategies, such as generating bytecode for a virtual machine, generating native code for a specific platform, or generating code in another high-level language.

2. Implement a simple interpreter or code generator for your language. This could involve walking the AST and directly executing the corresponding actions (in the case of an interpreter) or translating the AST into another language (in the case of a code generator).

3. Write test cases to validate the correctness of your compiler or interpreter. Create a set of example programs that cover various language features and edge cases. Test your implementation against these examples to identify and fix any bugs or issues.

4. (Optional) If time permits, start exploring simple optimizations, such as constant folding or dead code elimination, which can be applied during the code generation or interpretation process.
